import log from 'electron-log';
import AppConfig from '../../../config/AppConfigModule';
import { ITask } from '../Task';
import { modelProvider } from '../../services/ModelProvider';
import { Vulnerability } from '../../model/entity/Vulnerability';
import * as VulnerabilityMessages from '../grpc/scanoss/api/vulnerabilities/v2/scanoss-vulnerabilities_pb';
import { StatusCode } from '../grpc/scanoss/api/common/v2/scanoss-common_pb';
// eslint-disable-next-line import/extensions
import { VulnerabilityScanner, Component, ComponentsVulnerabilitiesResponse, VulnerabilityCfg } from 'scanoss';
import { userSettingService } from '../../services/UserSettingService';
import { workspace } from '../../workspace/Workspace';

export interface IVulnerabilityTask {
  components: Array<string>;
  force?:boolean;
}

export class AddVulnerabilityTask implements ITask<IVulnerabilityTask, void> {

  private getVulnerabilityScanner(): VulnerabilityScanner {
    const cfg = new VulnerabilityCfg();
    const project = workspace.getOpenProject();
    const {
      DEFAULT_API_INDEX,
      APIS,
      HTTP_PROXY,
      HTTPS_PROXY,
      PAC_PROXY,
      CA_CERT,
      IGNORE_CERT_ERRORS,
    } = userSettingService.get();

    if (project.getApi()) {
      cfg.API_URL = project.getApi();
      cfg.API_KEY = project.getApiKey();
    } else {
      cfg.API_URL = APIS[DEFAULT_API_INDEX].URL + AppConfig.API_SCAN_PATH;
      cfg.API_KEY = APIS[DEFAULT_API_INDEX].API_KEY;
    }
    const PAC_URL = PAC_PROXY ? `pac+${PAC_PROXY.trim()}` : null;
    cfg.HTTP_PROXY = PAC_URL || HTTP_PROXY || '';
    cfg.HTTPS_PROXY = PAC_URL || HTTPS_PROXY || '';

    cfg.IGNORE_CA_CERT_ERR = IGNORE_CERT_ERRORS || false;
    cfg.CA_CERT = CA_CERT ? CA_CERT : null;
    return new VulnerabilityScanner(cfg);
  }

  private async insertVulnerabilities(response: ComponentsVulnerabilitiesResponse) {
    const vulnerabilities = this.groupVulnerabilitiesByCVE(response);
    if (vulnerabilities.length > 0) {
      await modelProvider.model.vulnerability.insertAll(vulnerabilities);
      await modelProvider.model.vulnerability.insertComponentVulnerability(response);
    }
  }

  private async scanVulnerabilities(components: Array<string>) {
    const scanner = this.getVulnerabilityScanner();
    const componentRequest = components.map((c) => { return { purl: c } });
    return await scanner.getVulnerabilitiesComponents(componentRequest);
  }

  private groupVulnerabilitiesByCVE(vulnerabilities: ComponentsVulnerabilitiesResponse): Array<Vulnerability> {
    const vul: Record<string, Vulnerability> = {};
    vulnerabilities.components.forEach((p) => {
      p.vulnerabilities.forEach((v) => {
        const key = `${v.cve}${v.id}`;
        if (!vul[key]) vul[key] = Object.assign(new Vulnerability(), {...v, external_id:v.id});
      });
    });
    return Object.values(vul);
  }

  public async run(params: IVulnerabilityTask): Promise<void> {
    try {
      if (!AppConfig.FF_ENABLE_SCAN_VULNERABILITY) return;
      const response = await this.scanVulnerabilities(params.components);
      // Delete All vulnerabilities if force flag is true
      if (params.force) await modelProvider.model.vulnerability.deleteAll();
      await this.insertVulnerabilities(response);
    } catch (err: any) {
      log.error('[Add Vulnerability Task]:', err);
      throw err;
    }
  }
}
