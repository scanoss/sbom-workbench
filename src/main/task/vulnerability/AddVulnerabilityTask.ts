import log from 'electron-log';
import AppConfig from '../../../config/AppConfigModule';
import { ITask } from '../Task';
import { modelProvider } from '../../services/ModelProvider';
import { Vulnerability } from '../../model/entity/Vulnerability';
import * as VulnerabilityMessages from '../grpc/scanoss/api/vulnerabilities/v2/scanoss-vulnerabilities_pb';
import { StatusCode } from '../grpc/scanoss/api/common/v2/scanoss-common_pb';
// eslint-disable-next-line import/extensions
import { gRPCConnections } from '../grpc/gRPCConnection/gRPCConnection';
import { GetVulnerabilityRequestBuilder } from './builders/GetVulnerabilityRequestBuilder';
import { VulnerabilitiesClient } from '../grpc/scanoss/api/vulnerabilities/v2/scanoss-vulnerabilities_grpc_pb';
import { VulnerabilityResponse } from '../grpc/scanoss/api/vulnerabilities/v2/scanoss-vulnerabilities_pb';



export interface IVulnerabilityTask {
  components: Array<string>;
  force?:boolean;
}

export class AddVulnerabilityTask implements ITask<IVulnerabilityTask, void> {
  public async run(params: IVulnerabilityTask): Promise<void> {
    try {
      if (!AppConfig.FF_ENABLE_SCAN_VULNERABILITY) return;

      const response = await this.scanVulnerabilities(params.components);

      // Delete All vulnerabilities if force flag is true
      if (params.force) await modelProvider.model.vulnerability.deleteAll();
      await this.insertVulnerabilities(response);
    } catch (err: any) {
      log.error('[Add Vulnerability Task]:', err);
      throw err;
    }
  }

  private async insertVulnerabilities(response: any) {
    const vulnerabilities = this.groupVulnerabilitiesByCVE(response);
    if (vulnerabilities.length > 0) {
      await modelProvider.model.vulnerability.insertAll(vulnerabilities);
      await modelProvider.model.vulnerability.insertComponentVulnerabilityFromGRPC(response.purlsList);
    }
  }

  private async scanVulnerabilities(components: Array<string>) {
    const client = await gRPCConnections.getVulnerabilityStub() as VulnerabilitiesClient;
    // Split components into chunks
    const chunks = [];
    for (let i = 0; i < components.length; i += AppConfig.DEFAULT_SERVICE_CHUNK_LIMIT) {
      chunks.push(components.slice(i, i + AppConfig.DEFAULT_SERVICE_CHUNK_LIMIT));
    }

    // Process each chunk and collect promises
    const promises = chunks.map(async (chunk) => {
      const data = {
        purls: chunk.map((item) => ({ purl: item })),
      };

      const req = GetVulnerabilityRequestBuilder.build(data);
      try {
        const response = await new Promise((resolve, reject) => {
          client.getVulnerabilities(req, (err, resp) => {
            if (err) {
              reject(err);
            } else {
              resolve(resp);
            }
          });
        }) as VulnerabilityMessages.VulnerabilityResponse;

        if (response.getStatus().getStatus() !== StatusCode.SUCCESS) {
          log.error('[ VulnerabilityTask ] Request failed for purls:', chunk.map((item: any) => item.purl));
          log.error(`Error message: ${response.getStatus().getMessage()}`);
          return null;
        }
        return response.toObject();
      } catch (err: any) {
        log.error('[ VulnerabilityTask ] Request failed for purls:', chunk.map((item: any) => item.purl));
        log.error('Error:', err);
        return null;
      }
    });

    const results = await Promise.all(promises);
    return results.reduce((acc, curr) => {
      if (!curr) return acc;

      return {
        purlsList: [...(acc.purlsList || []), ...(curr.purlsList || [])],
        status: curr.status,
      };
    }, { purlsList: [], status: null });
  }

  private groupVulnerabilitiesByCVE(vulnerabilities: any): Array<Vulnerability> {
    const vul: Record<string, Vulnerability> = {};
    vulnerabilities.purlsList.forEach((p) => {
      p.vulnerabilitiesList.forEach((v) => {
        const key = `${v.cve}${v.id}`;
        if (!vul[key]) vul[key] = Object.assign(new Vulnerability(), {...v, external_id:v.id});
      });
    });
    return Object.values(vul);
  }
}
