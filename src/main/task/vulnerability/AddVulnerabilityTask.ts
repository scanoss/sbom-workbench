import log from 'electron-log';
import AppConfig from '../../../config/AppConfigModule';
import { ITask } from '../Task';
import { modelProvider } from '../../services/ModelProvider';
import { Vulnerability } from '../../model/entity/Vulnerability';
import * as VulnerabilityMessages from '../grpc/scanoss/api/vulnerabilities/v2/scanoss-vulnerabilities_pb';
import { StatusCode } from '../grpc/scanoss/api/common/v2/scanoss-common_pb';
// eslint-disable-next-line import/extensions
import { gRPCConnections } from '../grpc/gRPCConnection/gRPCConnection';
import { GetVulnerabilityRequestBuilder } from './builders/GetVulnerabilityRequestBuilder';
import { VulnerabilitiesClient } from '../grpc/scanoss/api/vulnerabilities/v2/scanoss-vulnerabilities_grpc_pb';

export interface IVulnerabilityTask {
  components: Array<string>;
  force?:boolean;
}

export class AddVulnerabilityTask implements ITask<IVulnerabilityTask, void> {
  public async run(params: IVulnerabilityTask): Promise<void> {
    try {
      if (!AppConfig.FF_ENABLE_SCAN_VULNERABILITY) return;

      const respJSON = await this.scanVulnerabilities(params.components);

      // Delete All vulnerabilities if force flag is true
      if (params.force) await modelProvider.model.vulnerability.deleteAll();
      await this.insertVulnerabilities(respJSON);
    } catch (err: any) {
      log.error("[Add Vulnerability Task]:", err);
      throw err;
    }
  }

  private async insertVulnerabilities(respJSON: any) {
    const vulnerabilities = this.groupVulnerabilitiesByCVE(respJSON);
    if (vulnerabilities.length > 0) {
      await modelProvider.model.vulnerability.insertAll(vulnerabilities);
      await modelProvider.model.vulnerability.insertComponentVulnerabilityFromGRPC(respJSON.purlsList);
    }
  }

  private async scanVulnerabilities(components: Array<string>) {
    const client = gRPCConnections.getVulnerabilityStub() as VulnerabilitiesClient;
    const data = {
      purls: components.map((item) => ({ purl: item })),
    };

    const req = GetVulnerabilityRequestBuilder.build(data);

    const pGetVulnerabilities = new Promise((resolve, reject) => {
      client.getVulnerabilities(req, (err, resp) => {
        if (err){
          reject(err);
        } 
        else resolve(resp);
      });
    });

    const response = (await pGetVulnerabilities) as VulnerabilityMessages.VulnerabilityResponse;
    if (response.getStatus().getStatus() !== StatusCode.SUCCESS) throw new Error(response.getStatus().getMessage());
    return response.toObject();
  }

  private groupVulnerabilitiesByCVE(vulnerabilities: any): Array<Vulnerability> {
    const vul: Record<string, Vulnerability> = {};
    vulnerabilities.purlsList.forEach((p) => {
      p.vulnerabilitiesList.forEach((v) => {
        if (!vul[v.cve]) vul[v.cve] = Object.assign(new Vulnerability(), v);
      });
    });
    return Object.values(vul);
  }
}
