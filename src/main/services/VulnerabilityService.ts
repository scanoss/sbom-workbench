import { ComponentVulnerability } from 'main/model/entity/ComponentVulnerability';
import { NewComponentDTO } from '@api/types';
import log from 'electron-log';
import { AddVulnerabilityTask } from '../task/vulnerability/AddVulnerabilityTask';
import { modelProvider } from './ModelProvider';
import { SourceType } from '../../api/dto';

class VulnerabilityService {
  public async getAll(
    type: SourceType,
  ): Promise<Array<ComponentVulnerability>> {
    const response = type === SourceType.detected
      ? await modelProvider.model.vulnerability.getAllDetected()
      : await modelProvider.model.vulnerability.getAllIdentified();
    return response;
  }

  public async updateFromComponents(newComponentDTOs: NewComponentDTO[]) {
    log.info('%c[ Vulnerability ]: Importing vulnerability into database', 'color: green');
    // Adds component's vulnerabilities
    const addVulnerability = new AddVulnerabilityTask();
    const components = this.adaptToVulnerabilityTask(newComponentDTOs);
    await addVulnerability.run({ components });
  }

  private adaptToVulnerabilityTask(components: NewComponentDTO[]): Array<string> {
    const response = components
      .map((component: NewComponentDTO) => component.versions.map((v) => `${component.purl}@${v.version}`));

    return response.flat();
  }

  public async update() {
    try {
      const comp = await modelProvider.model.component.getAll(null);
      const components = comp.flatMap((c) => `${c.purl}@${c.version}`);
      const vulnerabilityTask = new AddVulnerabilityTask();
      await vulnerabilityTask.run({ components, force: true });

      const detected = await modelProvider.model.vulnerability.getAllDetected();
      const identified = await modelProvider.model.vulnerability.getAllIdentified();

      return {
        detected,
        identified,
      };
    } catch (e) {
      throw new Error('Unable to extract vulnerability data');
    }
  }
}

export const vulnerabilityService = new VulnerabilityService();
