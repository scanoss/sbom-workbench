import { Model } from './Model';

import { Vulnerability } from './entity/Vulnerability';
import { ComponentVulnerability } from './entity/ComponentVulnerability';
import { ComponentVulnerability as gRPCComponentVulnerability } from './interfaces/ModelTypes';
import { ComponentVersion } from './entity/ComponentVersion';
import { Querys } from './querys_db';

const util = require('util');

export class VulnerabilityModel extends Model {
  public constructor(path: string) {
    super(path);
  }

  public async insertAll(vulnerability: Array<Vulnerability>): Promise<void> {
    return new Promise<void>(async (resolve) => {
      const db = await this.openDb();
      db.serialize(async () => {
        db.run('begin transaction');
        vulnerability.forEach((v) => {
          db.run(
            `INSERT OR IGNORE INTO vulnerability (CVE,source,severity,introduced,reported,patched,summary) VALUES(?,?,?,?,?,?,?);`,
            v.cve,
            v.source,
            v.severity,
            v.introduced,
            v.reported,
            v.patched,
            v.summary
          );
        });
        db.run('commit', (error) => {
          if (error) throw error;
          resolve();
        });
      });
    });
  }

  public insertComponentVulnerabilityFromGRPC(
    data: Array<gRPCComponentVulnerability> // TODO: reeplace ComponentVulnerability by gRPC proto
  ): Promise<void> {
    return new Promise<void>(async (resolve) => {
      const db = await this.openDb();
      db.serialize(async () => {
        db.run('begin transaction');
        data.forEach((d) => {
          const purl = d.purl.substring(0, d.purl.lastIndexOf('@'));
          const version = d.purl.substring(
            d.purl.lastIndexOf('@') + 1,
            d.purl.length
          );
          d.vulnerabilities.forEach((v) => {
            db.run(
              `INSERT OR IGNORE INTO component_vulnerability (CVE,purl,version) VALUES (?,?,?);`,
              v.cve,
              purl,
              version
            );
          });
        });
        db.run('commit', (error) => {
          if (error) throw error;
          resolve();
        });
      });
    });
  }

  public async getAllDetected(): Promise<Array<ComponentVulnerability>> {
    const db = await this.openDb();
    const query = new Querys().SQL_GET_ALL_VULNERABILITIES_DETECTED;
    const call = util.promisify(db.all.bind(db));
    const response = await call(query);
    const entities = this.vulnerabilityAdapter(response);
    const components = await this.getComponentVersionForVulnerabilities(
      response
    );
    return this.addComponentVersionToRelation(components, entities);
  }

  public async getAllIdentified(): Promise<Array<ComponentVulnerability>> {
    const db = await this.openDb();
    const query = new Querys().SQL_GET_ALL_IDENTIFIED_VULNERABILITIES;
    const call = await util.promisify(db.all.bind(db));
    const response = await call(query);
    const entities = this.vulnerabilityAdapter(response);
    const components = await this.getComponentVersionForVulnerabilities(
      response
    );
    return this.addComponentVersionToRelation(components, entities);
  }

  public async getDetectedReport() {
    const db = await this.openDb();
    const query = new Querys().SQL_GET_VULNERABILITIES_DETECTED_REPORT;
    const call = await util.promisify(db.all.bind(db));
    const response = call(query);
    return response;
  }

  public async getIdentifiedReport() {
    const db = await this.openDb();
    const query = new Querys().SQL_GET_VULNERABILITIES_IDENTIFIED_REPORT;
    const call = util.promisify(db.all.bind(db));
    const response = call(query);
    return response;
  }

  /*
   * @brief get component@version array from vulnerabilities
   * @param componentVulnerabilities: Array with component vulnerabilities coming from database
   * @return array with component versions joined by @
   * */
  private getComponentVersion(componentVulnerabilities: any): Array<string> {
    return componentVulnerabilities.map((cv) => `${cv.purl}@${cv.version}`);
  }

  /*
   * @brief get an array of ComponentVersion associated to each vulnerability
   * @param data: Array with of component@version
   * @return return a partial ComponentVersion
   * */
  private async getComponentVersionForVulnerabilities(
    data: any
  ): Promise<Array<ComponentVersion>> {
    const components = this.getComponentVersion(data);
    const db = await this.openDb();
    const query =
      new Querys().SQL_GET_COMPONENT_VERSIONS_FOR_VULNERABILITIES.replace(
        '#COMPONENTS',
        `'${components.join("','")}'`
      );
    const call = util.promisify(db.all.bind(db));
    const response: Array<ComponentVersion> = await call(query);
    return response;
  }

  /*
   * @brief get ComponentVulnerability entity from vulnerability database data
   * @param data: Array with vulnerability data comming from database
   * @return return an Array of ComponentVulnerability
   * */
  private vulnerabilityAdapter(data: any): Array<ComponentVulnerability> {
    const componentVulnerability = data.map((cv: Record<string, string>) => {
      return {
        purl: cv.purl,
        version: cv.version,
        rejectAt: cv.rejectAt,
        vulnerability: {
          cve: cv.cve,
          source: cv.source,
          severity: cv.severity,
          introduced: cv.introduced,
          reported: cv.reported,
          patched: cv.patched,
          summary: cv.summary,
        },
      };
    });
    return componentVulnerability;
  }

  /*
   * @brief merge component version with component vulnerabilities
   * @param componentVersions : Array with ComponentVersions
   * @param componentVulnerabilities: Array with ComponentVulnerabilities
   * @return return Array of ComponentVulnerabilities
   * */
  private addComponentVersionToRelation(
    componentVersions: Array<ComponentVersion>,
    componentVulnerabilities: Array<ComponentVulnerability>
  ): Array<ComponentVulnerability> {
    const compVersionMapper = componentVersions.reduce((acc, cv) => {
      const key = `${cv.purl}@${cv.version}`;
      if (!acc[key]) acc[key] = cv;
      return acc;
    }, {});
    const entities = componentVulnerabilities.map(
      (componentVulnerability: ComponentVulnerability) => {
        componentVulnerability.componentVersion = Object.assign(
          new ComponentVersion(),
          compVersionMapper[
            `${componentVulnerability.purl}@${componentVulnerability.version}`
          ]
        );
        return componentVulnerability;
      }
    );
    return entities;
  }
}
