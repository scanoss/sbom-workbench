import {Model} from "./Model";
import {ComponentVulnerability, Vulnerability} from './interfaces/ModelTypes';

export class VulnerabilityModel extends Model{

  public constructor(path: string) {
    super(path);
  }

  public async insertBatch(vulnerability : Array<Vulnerability>):Promise<void>{
    return new Promise<void> (async (resolve) => {
    const db = await this.openDb();
    db.serialize(async () => {
      db.run('begin transaction');
      vulnerability.forEach((v)=>{
        db.run(`INSERT OR IGNORE INTO vulnerability (CVE,source,severity,introduced,reported,patched,summary) VALUES(?,?,?,?,?,?,?);`,
          v.cve,v.source,v.severity,v.introduced,v.reported,v.patched,v.summary);
      });
      db.run("commit",(error)=>{
        if(error) throw error;
        resolve();
      });
    });
    });
  }

  public insertComponentVulnerabilityFromGRPC(data : Array<ComponentVulnerability>): Promise<void> {
    return new Promise<void> (async (resolve) => {
      const db = await this.openDb();
      db.serialize(async () => {
        db.run('begin transaction');
        data.forEach((d)=>{
          const purl = d.purl.substring(0, d.purl.lastIndexOf('@'));
          const version = d.purl.substring((d.purl.lastIndexOf('@') + 1 ),d.purl.length);
          d.vulnerabilities.forEach((v)=> {
            db.run(`INSERT INTO component_vulnerability (CVE,purl,version) VALUES (?,?,?);`,v.cve,purl,version);
          });
        });
        db.run('commit',(error)=>{ if(error) throw error;
        resolve();
        })
      });
    });
  }

}
