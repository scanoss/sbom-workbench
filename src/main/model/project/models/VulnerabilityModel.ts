import util from 'util';
import { Vulnerability } from '../../entity/Vulnerability';
import { ComponentVulnerability } from '../../entity/ComponentVulnerability';
import { ComponentVulnerability as gRPCComponentVulnerability } from '../../interfaces/ModelTypes';
import { ComponentVersion } from '../../entity/ComponentVersion';
import { queries } from '../../querys_db';
import sqlite3 from 'sqlite3';
import { Model } from '../../Model';

export class VulnerabilityModel extends Model {

  private connection: sqlite3.Database;
  public constructor(conn: sqlite3.Database) {
    super();
    this.connection = conn;
  }

  public async insertAll(vulnerability: Array<Vulnerability>): Promise<void> {
    const call:any = util.promisify(this.connection.run.bind(this.connection));
    const promises = [];
    vulnerability.forEach((v) => {
      promises.push(call(
        'INSERT OR IGNORE INTO vulnerability (CVE,source,severity,published,modified,summary) VALUES(?,?,?,?,?,?);',
        v.cve,
        v.source,
        v.severity,
        v.published,
        v.modified,
        v.summary,
      ));
    });
    await Promise.all(promises);
  }

  public async insertComponentVulnerabilityFromGRPC(
    data: Array<gRPCComponentVulnerability>,
  ): Promise<void> {
    const call:any = util.promisify(this.connection.run.bind(this.connection));
    const promises = [];
    data.forEach((d) => {
      const purl = d.purl.substring(0, d.purl.lastIndexOf('@'));
      const version = d.purl.substring(d.purl.lastIndexOf('@') + 1, d.purl.length);
      d.vulnerabilitiesList.forEach((v) => {
        promises.push(call('INSERT OR IGNORE INTO component_vulnerability (CVE,purl,version) VALUES (?,?,?);', v.cve, purl, version));
      });
    });
    await Promise.all(promises);
  }

  public async getAllDetected(): Promise<Array<ComponentVulnerability>> {
    const query = queries.SQL_GET_ALL_VULNERABILITIES_DETECTED;
    const call = util.promisify(this.connection.all.bind(this.connection));
    const response = await call(query);
    const entities = this.vulnerabilityAdapter(response);
    const components = await this.getComponentVersionForVulnerabilities(
      response,
    );
    return this.addComponentVersionToRelation(components, entities);
  }

  public async getAllIdentified(): Promise<Array<ComponentVulnerability>> {
    const query = queries.SQL_GET_ALL_IDENTIFIED_VULNERABILITIES;
    const call = await util.promisify(this.connection.all.bind(this.connection));
    const response = await call(query);
    const entities = this.vulnerabilityAdapter(response);
    const components = await this.getComponentVersionForVulnerabilities(
      response,
    );
    return this.addComponentVersionToRelation(components, entities);
  }

  public async getDetectedReport() {
    const query = queries.SQL_GET_VULNERABILITIES_DETECTED_REPORT;
    const call = await util.promisify(this.connection.all.bind(this.connection));
    const response = call(query);
    return response;
  }

  public async getIdentifiedReport() {
    const query = queries.SQL_GET_VULNERABILITIES_IDENTIFIED_REPORT;
    const call = util.promisify(this.connection.all.bind(this.connection));
    const response = call(query);
    return response;
  }

  /*
   * @brief get component@version array from vulnerabilities
   * @param componentVulnerabilities: Array with component vulnerabilities coming from database
   * @return array with component versions joined by @
   * */
  private getComponentVersion(componentVulnerabilities: any): Array<string> {
    return componentVulnerabilities.map((cv) => `${cv.purl}@${cv.version}`);
  }

  /*
   * @brief get an array of ComponentVersion associated to each vulnerability
   * @param data: Array with of component@version
   * @return return a partial ComponentVersion
   * */
  private async getComponentVersionForVulnerabilities(
    data: any,
  ): Promise<Array<ComponentVersion>> {
    const components = this.getComponentVersion(data);
    const query = queries.SQL_GET_COMPONENT_VERSIONS_FOR_VULNERABILITIES.replace(
      '#COMPONENTS',
      `'${components.join("','")}'`,
    );
    const call:any = util.promisify(this.connection.all.bind(this.connection));
    const response: Array<ComponentVersion> = await call(query);
    return response;
  }

  /**
   * @brief get ComponentVulnerability entity from vulnerability database data
   * @param data: Array with vulnerability data comming from database
   * @return return an Array of ComponentVulnerability
  */
  private vulnerabilityAdapter(data: any): Array<ComponentVulnerability> {
    const componentVulnerability = data.map((cv: Record<string, string>) => ({
      purl: cv.purl,
      version: cv.version,
      rejectAt: cv.rejectAt,
      vulnerability: {
        cve: cv.cve,
        source: cv.source,
        severity: cv.severity,
        modified: cv.modified,
        published: cv.published,
        summary: cv.summary,
      },
    }));
    return componentVulnerability;
  }

  /*
   * @brief merge component version with component vulnerabilities
   * @param componentVersions : Array with ComponentVersions
   * @param componentVulnerabilities: Array with ComponentVulnerabilities
   * @return return Array of ComponentVulnerabilities
   * */
  private addComponentVersionToRelation(
    componentVersions: Array<ComponentVersion>,
    componentVulnerabilities: Array<ComponentVulnerability>,
  ): Array<ComponentVulnerability> {
    const compVersionMapper = componentVersions.reduce((acc, cv) => {
      const key = `${cv.purl}@${cv.version}`;
      if (!acc[key]) acc[key] = cv;
      return acc;
    }, {});
    const entities = componentVulnerabilities.map(
      (componentVulnerability: ComponentVulnerability) => {
        componentVulnerability.componentVersion = Object.assign(
          new ComponentVersion(),
          compVersionMapper[
            `${componentVulnerability.purl}@${componentVulnerability.version}`
          ],
        );
        return componentVulnerability;
      },
    );
    return entities;
  }

  public async deleteAll() {
    const query = queries.SQL_VULNERABILITY_DELETE_ALL;
    const call = await util.promisify(this.connection.run.bind(this.connection));
    await call(query);
  }
}
