import util from 'util';
import sqlite3 from 'sqlite3';
import { Vulnerability } from '../../entity/Vulnerability';
import { ComponentVulnerability } from '../../entity/ComponentVulnerability';
import { ComponentVulnerability as gRPCComponentVulnerability } from '../../interfaces/ModelTypes';
import { ComponentVersion } from '../../entity/ComponentVersion';
import { queries } from '../../querys_db';
import { Model } from '../../Model';
import { ComponentsVulnerabilitiesResponse } from 'scanoss';

export class VulnerabilityModel extends Model {
  private connection: sqlite3.Database;

  public constructor(conn: sqlite3.Database) {
    super();
    this.connection = conn;
  }

  public async insertAll(vulnerability: Array<Vulnerability>): Promise<void> {
    return new Promise<void>(async (resolve, reject) => {
      this.connection.serialize(async () => {
        this.connection.run('begin transaction');

        vulnerability.forEach((v) => {
          this.connection.run(
            'INSERT OR IGNORE INTO vulnerability (external_id,cve,source,severity,published,modified,summary) VALUES(?,?,?,?,?,?,?);',
            v.external_id,
            v.cve,
            v.source,
            v.severity,
            v.published,
            v.modified,
            v.summary,
          );
        });

        this.connection.run('commit', (err: any) => {
          if (!err) resolve();
          reject(err);
        });
      });
    });
  }

  public async insertComponentVulnerability(
    data: ComponentsVulnerabilitiesResponse,
  ): Promise<void> {
    const call:any = util.promisify(this.connection.run.bind(this.connection));
    const promises = [];
    data.components.forEach((c) => {
      c.vulnerabilities.forEach((v) => {
        promises.push(call('INSERT OR IGNORE INTO component_vulnerability (vulnerability_external_id, vulnerability_source, purl, version) VALUES (?,?,?,?);', v.id, v.source, c.purl, c.version));
      });
    });
    await Promise.all(promises);
  }

  public async getAllDetected(): Promise<Array<ComponentVulnerability>> {
    const query = queries.SQL_GET_ALL_VULNERABILITIES_DETECTED;
    const call = util.promisify(this.connection.all.bind(this.connection));
    const response = await call(query);
    const entities = this.vulnerabilityAdapter(response);
    const components = await this.getComponentVersionForVulnerabilities(
      response,
    );
    return this.addComponentVersionToRelation(components, entities);
  }

  public async getAllIdentified(): Promise<Array<ComponentVulnerability>> {
    const query = queries.SQL_GET_ALL_IDENTIFIED_VULNERABILITIES;
    const call = await util.promisify(this.connection.all.bind(this.connection));
    const response = await call(query);
    const entities = this.vulnerabilityAdapter(response);
    const components = await this.getComponentVersionForVulnerabilities(
      response,
    );
    return this.addComponentVersionToRelation(components, entities);
  }

  public async getDetectedReport() {
    const query = queries.SQL_GET_VULNERABILITIES_DETECTED_REPORT;
    const call = await util.promisify(this.connection.all.bind(this.connection));
    const response = call(query);
    return response;
  }

  public async getIdentifiedReport() {
    const query = queries.SQL_GET_VULNERABILITIES_IDENTIFIED_REPORT;
    const call = util.promisify(this.connection.all.bind(this.connection));
    const response = call(query);
    return response;
  }

  /*
   * @brief get component@version array from vulnerabilities
   * @param componentVulnerabilities: Array with component vulnerabilities coming from database
   * @return array with component versions joined by @
   * */
  private getComponentVersion(componentVulnerabilities: any): Array<string> {
    return componentVulnerabilities.map((cv) => `${cv.purl}@${cv.version}`);
  }

  /*
   * @brief get an array of ComponentVersion associated to each vulnerability
   * @param data: Array with of component@version
   * @return return a partial ComponentVersion
   * */
  private async getComponentVersionForVulnerabilities(
    data: any,
  ): Promise<Array<ComponentVersion>> {
    const components = this.getComponentVersion(data);
    const query = queries.SQL_GET_COMPONENT_VERSIONS_FOR_VULNERABILITIES.replace(
      '#COMPONENTS',
      `'${components.join("','")}'`,
    );
    const call:any = util.promisify(this.connection.all.bind(this.connection));
    const response: Array<ComponentVersion> = await call(query);
    return response;
  }

  /**
   * @brief get ComponentVulnerability entity from vulnerability database data
   * @param data: Array with vulnerability data comming from database
   * @return return an Array of ComponentVulnerability
  */
  private vulnerabilityAdapter(data: any): Array<ComponentVulnerability> {
    const componentVulnerability = data.map((cv: Record<string, string>) => ({
      purl: cv.purl,
      version: cv.version,
      rejectAt: cv.rejectAt,
      vulnerability: {
        external_id: cv.external_id,
        cve: cv.cve,
        source: cv.vsource,
        severity: cv.severity,
        modified: cv.modified,
        published: cv.published,
        summary: cv.summary,
      },
    }));
    return componentVulnerability;
  }

  /*
   * @brief merge component version with component vulnerabilities
   * @param componentVersions : Array with ComponentVersions
   * @param componentVulnerabilities: Array with ComponentVulnerabilities
   * @return return Array of ComponentVulnerabilities
   * */
  private addComponentVersionToRelation(
    componentVersions: Array<ComponentVersion>,
    componentVulnerabilities: Array<ComponentVulnerability>,
  ): Array<ComponentVulnerability> {
    const compVersionMapper = componentVersions.reduce((acc, cv) => {
      const key = `${cv.purl}@${cv.version}`;
      if (!acc[key]) acc[key] = cv;
      return acc;
    }, {});
    const entities = componentVulnerabilities.map(
      (componentVulnerability: ComponentVulnerability) => {
        componentVulnerability.componentVersion = Object.assign(
          new ComponentVersion(),
          compVersionMapper[
            `${componentVulnerability.purl}@${componentVulnerability.version}`
          ],
        );
        return componentVulnerability;
      },
    );
    return entities;
  }

  public async deleteAll() {
    const query = queries.SQL_VULNERABILITY_DELETE_ALL;
    const call = await util.promisify(this.connection.run.bind(this.connection));
    await call(query);
  }
}
